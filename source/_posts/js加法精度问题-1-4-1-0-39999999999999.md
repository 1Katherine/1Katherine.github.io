---
title: js加法精度问题 1.4-1=0.39999999999999
date: 2022-07-22 11:07:18
tags:
categories:项目知识
 
---

## 参考文章

1. JS精度问题终结者--math.js之Vue中使用心得【https://blog.csdn.net/CherryLee_1210/article/details/80805681】

2. javascript的精度问题，包含原因和解决方案-面试总结【https://juejin.cn/post/7051103304780103716】

## 前言

最近接手了别人写完（但没有测试）的前端项目，之前的前端离职了，但是甲方还在加需求。so？我要在别人的代码基础上加需求、改需求、还要改别人的一堆bug，也算是成长了不少。在别人的基础上总比从零开始好。写得好的地方还能学习借鉴。但是，由于之前的甲方频繁改需求，代码看着乱糟糟的，阅读起来的确不是很流畅，但是码农应该都能理解吧，之前写的代码由于需求变了需要删除，怎么也舍不得删除，毕竟花了心思写的，而且万一后面需求变多之前的代码又要用了呢，留个记录在那里也方便自己后续理解代码。但是别人就不懂，就觉得代码乱糟糟的。我刚开始也不理解，不用的代码为什么不删除，为啥还有留在那里，还容易产生误导。慢慢我也理解了，因为！我上次没有删除不用的代码，而是备注，导致被上一个甲方负责人说了一顿，嫌我代码乱，不方便甲方的技术人员阅读。我还怕他万一后期改需求，我代码干干净净的，我都不知道当时咋写的呢。唉，他人不懂码农的心酸呐~~~~~~

好了，回归正文。这次是遇到了JS精度的问题，导致1.4-1=0.39999999，页面显示非常不美观！

![image-20220722111627458](js加法精度问题-1-4-1-0-39999999999999/image-20220722111627458.png)

## 产生原因

JavaScript 中的数字按照 IEEE 754 的标准，使用 64 位双精度浮点型来表示。

*IEEE754存储规则*

![image-20220722112404519](js加法精度问题-1-4-1-0-39999999999999/image-20220722112404519.png)

比如：0.1+0.2=0.300000000004

十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的：

~~~
0.1 -> 0.0001 1001 1001 1001...(1100循环)
0.2 -> 0.0011 0011 0011 0011...(0011循环)
~~~

EEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：

~~~
0.0100110011001100110011001100110011001100110011001100 
~~~

因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。

## 解决方法

可以自己写一套逻辑处理，但是既然是生产环境使用，当然是需要用确保万无一失的方法：调包！

安装math.js

~~~
npm install mathjs
~~~

在Vue组件中引入

~~~
let math = require('mathjs')
~~~

使用方法

~~~javascript
0.1＋0.2
math.format(math.chain(math.bignumber(0.1)).add(math.bignumber(0.2)).done());

0.2-0.1
math.format(math.chain(math.bignumber(0.2)).subtract(math.bignumber(0.1)).done());

0.1*0.2
math.format(math.chain(math.bignumber(0.1)).multiply(math.bignumber(0.2)).done());

0.1/0.2
math.format(math.chain(math.bignumber(0.1)).divide(math.bignumber(0.2)).done());

~~~

如图1.4+0+(-1)，假设为score1+score2+score3

~~~javascript
let num = math.format(math        .chain(math.bignumber(score1))         .add(math.bignumber(score2).add(math.bignumber(score3))) .done());
~~~

